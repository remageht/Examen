### Конструкторы

**Конструктор по умолчанию (Default Constructor)**

- **Реализация, предоставляемая компилятором (Implementation provided by the compiler)**:
    
    - Если вы не определите конструктор в классе, компилятор автоматически создаст конструктор по умолчанию, который не принимает параметров и инициализирует члены данных значениями по умолчанию.
        
    - Пример:
        
        ```cpp
        class MyClass {
        public:
            MyClass() = default; // Конструктор по умолчанию
        ```

**Конструктор с несколькими параметрами (Constructor with multiple parameters)**

	- **Описание**: Конструкторы могут принимать несколько параметров для инициализации членов класса.
    
- Пример:
    
    ```cpp
    class MyClass {
    private:
        int x, y;
    public:
        MyClass(int a, int b) : x(a), y(b) {} // Инициализация списка
    };
    ```
    

**Делегирующие конструкторы (Delegating Constructors)**

- **Описание**: Делегирующие конструкторы позволяют одному конструктору вызывать другой конструктор того же класса для инициализации.
    
- Пример:
    
    ```cpp
    class MyClass {
    private:
        int x, y;
    public:
        MyClass(int a) : MyClass(a, 0) {} // Делегирующий конструктор
        MyClass(int a, int b) : x(a), y(b) {}
    };
    ```
    

**Инициализация полей (Field Initialization)**

- **Внутри тела конструктора (Inside the constructor body)**:
    
    - Описание: Инициализация членов данных может выполняться внутри тела конструктора.
        
    - Пример:
        
        ```cpp
        class MyClass {
        private:
            int x, y;
        public:
            MyClass(int a, int b) {
                x = a;
                y = b;
            }
        };
        ```
        
- **Списки инициализаторов (Initializer lists)**:
    
    - Описание: Списки инициализаторов используются для инициализации членов данных до выполнения тела конструктора.
        
    - Пример:
        
        ```cpp
        class MyClass {
        private:
            int x, y;
        public:
            MyClass(int a, int b) : x(a), y(b) {}
        };
        ```
        
- **Особенности инициализации констант и ссылок (Features of initializing constants and references)**:
    
    - Описание: Константы и ссылки должны быть инициализированы в списке инициализаторов.
        
    - Пример:
        
        ```cpp
        class MyClass {
        private:
            const int x;
            int& y;
        public:
            MyClass(int a, int& b) : x(a), y(b) {}
        };
        ```
        
- **Инициализация полей в точке объявления (Field initialization at the point of declaration)**:
    
    - Описание: Члены данных могут быть инициализированы при их объявлении в классе.
        
    - Пример:
        
        ```cpp
        class MyClass {
        private:
            int x = 0;
            int y = 0;
        public:
            MyClass() {}
        };
        ```
        
- **Порядок инициализации полей (Order of field initialization)**:
    
    - Описание: Порядок инициализации членов данных зависит от порядка их объявления в классе, а не от порядка в списке инициализаторов.
        
    - Пример:
        
        ```cpp
        class MyClass {
        private:
            int x;
            int y;
        public:
            MyClass(int a, int b) : y(b), x(a) {} // Сначала инициализируется x, затем y
        };
        ```
        

**Порядок вызова конструкторов при наследовании (Order of constructor calls during inheritance)**

- **Описание**: В случае наследования сначала вызывается конструктор базового класса, затем производного класса.
    
- Пример:
    
    ```cpp
    class Base {
    public:
        Base() {
            std::cout << "Base Constructor" << std::endl;
        }
    };
    
    class Derived : public Base {
    public:
        Derived() {
            std::cout << "Derived Constructor" << std::endl;
        }
    };
    
    int main() {
        Derived obj;
        // Вывод:
        // Base Constructor
        // Derived Constructor
    }
    ```
    

### Конструктор копирования (Copy Constructor)

**Виды копирования (Types of copying)**

- **Поверхностное (побайтовое) копирование (Shallow (byte-by-byte) copying)**:
    
    - Описание: Поверхностное копирование создает новый объект, копируя значения всех членов данных из исходного объекта.
        
    - Пример:
        
        ```cpp
        class MyClass {
        public:
            int* data;
            MyClass(int value) {
                data = new int(value);
            }
            // Конструктор копирования
            MyClass(const MyClass& other) {
                data = other.data;
            }
        };
        ```
        
- **Глубокое копирование (Deep copying)**:
    
    - Описание: Глубокое копирование создает новый объект, копируя значения всех членов данных, включая динамически выделенную память.
        
    - Пример:
        
        ```cpp
        class MyClass {
        public:
            int* data;
            MyClass(int value) {
                data = new int(value);
            }
            // Конструктор копирования
            MyClass(const MyClass& other) {
                data = new int(*other.data);
            }
        };
        ```
        

**Варианты реализации (Implementation options)**

- **Конструктор копирования при передаче объектов в функцию (Copy constructor when passing objects to a function)**:
    
    - Описание: Конструктор копирования вызывается, когда объект передается в функцию по значению.
        
    - Пример:
        
        ```cpp
        void function(MyClass obj) {
            // Копирование obj
        }
        
        int main() {
            MyClass obj(10);
            function(obj); // Вызов конструктора копирования
        }
        ```
        
- **Конструктор копирования при возврате объектов из функции (Copy constructor when returning objects from a function)**:
    
    - Описание: Конструктор копирования вызывается, когда объект возвращается из функции по значению.
        
    - Пример:
        
        ```cpp
        MyClass function() {
            MyClass obj(10);
            return obj; // Вызов конструктора копирования
        }
        
        int main() {
            MyClass obj = function(); // Вызов конструктора копирования
        }
        ```

### Оператор присваивания копированием (Copy Assignment Operator)

Оператор присваивания копированием используется для копирования значений одного объекта в другой уже существующий объект того же типа. Важно правильно обработать все ресурсы, чтобы избежать утечек памяти и других проблем.

#### Реализация оператора присваивания копированием

- **Общая схема реализации**:
    
    1. **Проверка самоприсваивания**: Проверить, не присваивается ли объект сам себе.
        
    2. **Освобождение ресурсов**: Освободить ресурсы текущего объекта.
        
    3. **Копирование ресурсов**: Копировать ресурсы из другого объекта.
        

#### Пример:

```cpp
class MyClass {
public:
    int* data;

    MyClass(int value) {
        data = new int(value);
    }

    MyClass& operator=(const MyClass& other) {
        if (this == &other) {
            return *this; // Проверка самоприсваивания
        }

        delete data; // Освобождение текущих ресурсов
        data = new int(*other.data); // Копирование ресурсов

        return *this;
    }

    ~MyClass() {
        delete data; // Освобождение памяти
    }
};
```

### Конструктор перемещения (Move Constructor)

Конструктор перемещения используется для переноса ресурсов из одного объекта в другой, минимизируя затраты на копирование. Это особенно полезно для объектов, которые владеют динамическими ресурсами.

#### Реализация конструктора перемещения

- **Общая схема реализации**:
    
    1. **Передача ресурсов**: Перенести ресурсы из исходного объекта.
        
    2. **Оставить исходный объект в валидном состоянии**.
        

#### Пример:

```cpp
class MyClass {
public:
    int* data;

    MyClass(int value) {
        data = new int(value);
    }

    // Конструктор перемещения
    MyClass(MyClass&& other) noexcept {
        data = other.data; // Перенос ресурсов
        other.data = nullptr; // Оставляем исходный объект в валидном состоянии
    }

    ~MyClass() {
        delete data; // Освобождение памяти
    }
};
```

### Деструктор (Destructor)

Деструктор используется для освобождения ресурсов, которыми владеет объект, когда этот объект уничтожается. Это предотвращает утечки памяти и освобождает другие ресурсы, такие как файлы или сетевые соединения.

#### Реализация деструктора

- **Общая схема реализации**:
    
    1. **Освобождение ресурсов**: Освободить все ресурсы, которыми владеет объект.
        

#### Пример:

```cpp
class MyClass {
public:
    int* data;

    MyClass(int value) {
        data = new int(value);
    }

    ~MyClass() {
        delete data; // Освобождение памяти
    }
};
```

### Важные моменты

1. **Порядок вызова деструкторов при наследовании**:
    
    - Деструкторы вызываются в порядке, обратном порядку вызова конструкторов, начиная с деструктора самого производного класса и заканчивая базовым классом.
        
2. **Виртуальные деструкторы (Virtual Destructors)**:
    
    - Виртуальные деструкторы необходимы в базовых классах, чтобы гарантировать корректное освобождение ресурсов при удалении объектов производных классов через указатель на базовый класс.
        

#### Пример:

```cpp
class Base {
public:
    virtual ~Base() {
        // Освобождение ресурсов базового класса
    }
};

class Derived : public Base {
public:
    ~Derived() override {
        // Освобождение ресурсов производного класса
    
```