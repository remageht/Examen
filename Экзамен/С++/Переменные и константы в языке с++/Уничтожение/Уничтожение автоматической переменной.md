В C++ автоматические переменные — это переменные, которые создаются на стеке и имеют автоматическую продолжительность хранения (automatic storage duration). Они автоматически уничтожаются при выходе из области видимости, в которой они были объявлены. Это один из ключевых механизмов управления памятью в C++, который помогает избежать утечек памяти и упрощает управление ресурсами.
_______________________________________________________________________________________________________________________________________________________________________________________
### Когда уничтожаются автоматические переменные?
Автоматические переменные уничтожаются в следующих случаях:

#### 1.При выходе из блока (области видимости):

Когда выполнение программы выходит за пределы блока (например, закрывающей фигурной скобки }), все автоматические переменные, объявленные в этом блоке, уничтожаются.

Пример:

```
void foo() {
    int x = 10;  // Автоматическая переменная
    std::cout << x << std::endl;
}  // x уничтожается здесь
```
#### 2.При выходе из функции:

Когда функция завершает своё выполнение (возвращает значение или достигает конца), все её локальные переменные уничтожаются.

Пример:

```
int bar() {
    int y = 20;  // Автоматическая переменная
    return y;
}  // y уничтожается здесь
```
#### 3.При выходе из цикла или условного блока:

Переменные, объявленные внутри цикла или условного блока, уничтожаются при завершении этого блока.

Пример:

```
for (int i = 0; i < 5; i++) {
    int z = i * 2;  // Автоматическая переменная
    std::cout << z << std::endl;
}  // z уничтожается здесь после каждой итерации
```
_______________________________________________________________________________________________________________________________________________________________________________________
### Как происходит уничтожение?
#### 1.Для простых типов (например, int, float, указатели):

Память, выделенная для переменной, просто освобождается. Никаких дополнительных действий не требуется.

#### 2.Для объектов классов:

Если переменная является объектом класса, то перед освобождением памяти вызывается деструктор этого класса. Деструктор отвечает за освобождение ресурсов, которые могли быть выделены объектом (например, динамическая память, файловые дескрипторы и т. д.).

Пример:

```
class MyClass {
public:
    MyClass() { std::cout << "Constructor" << std::endl; }
    ~MyClass() { std::cout << "Destructor" << std::endl; }
};

void baz() {
    MyClass obj;  // Создаётся объект, вызывается конструктор
}  // obj уничтожается, вызывается деструктор
```
Вывод:

```
Constructor
Destructor
```
### Примеры
#### 1.Уничтожение переменной в блоке:

```
{
    int x = 42;  // Автоматическая переменная
    std::cout << x << std::endl;
}  // x уничтожается здесь
```
#### 2.Уничтожение объекта класса:

```
{
    std::string str = "Hello";  // Автоматическая переменная (объект класса)
    std::cout << str << std::endl;
}  // str уничтожается, вызывается деструктор std::string
#### 3.Уничтожение переменной в цикле:
```
```
for (int i = 0; i < 3; i++) {
    int temp = i * 10;  // Автоматическая переменная
    std::cout << temp << std::endl;
}  // temp уничтожается после каждой итерации
```
_______________________________________________________________________________________________________________________________________________________________________________________
### Преимущества автоматического уничтожения
#### 1.Упрощение управления памятью:

Вам не нужно вручную освобождать память, как в случае с динамической памятью (выделенной через new).

#### 2.Избежание утечек памяти:

Поскольку переменные уничтожаются автоматически, риск утечек памяти значительно снижается.

#### 3.Безопасность:

Автоматическое уничтожение помогает избежать ошибок, связанных с использованием неинициализированной или освобождённой памяти.

#### Исключения и автоматические переменные
Если в блоке или функции возникает исключение, все автоматические переменные, созданные в этом блоке, всё равно уничтожаются. Это называется stack unwinding (раскрутка стека). Деструкторы объектов вызываются в порядке, обратном их созданию.

Пример:

```
class MyClass {
public:
    MyClass() { std::cout << "Constructor" << std::endl; }
    ~MyClass() { std::cout << "Destructor" << std::endl; }
};

void test() {
    MyClass obj;
    throw std::runtime_error("Error");  // Исключение
}  // obj уничтожается, вызывается деструктор

int main() {
    try {
        test();
    } catch (const std::exception& e) {
        std::cout << "Exception caught: " << e.what() << std::endl;
    }
    return 0;
}
```
Вывод:

```
Constructor
Destructor
Exception caught: Error
```
_______________________________________________________________________________________________________________________________________________________________________________________
### Итог
Автоматические переменные уничтожаются при выходе из области видимости, в которой они были объявлены.

Для объектов классов вызывается деструктор перед освобождением памяти.

Автоматическое уничтожение упрощает управление памятью и помогает избежать утечек.

Даже при возникновении исключений автоматические переменные корректно уничтожаются благодаря механизму раскрутки стека.