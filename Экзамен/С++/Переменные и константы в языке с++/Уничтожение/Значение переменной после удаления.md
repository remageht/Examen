После удаления динамически созданной переменной с помощью оператора delete, значение указателя на эту переменную становится неопределённым. Это означает, что указатель продолжает хранить адрес памяти, который больше не принадлежит вашей программе. Использование такого указателя приводит к неопределённому поведению (Undefined Behavior, UB).
________________________________________________________________________________________________________________________________________________________________________________________________
### Что происходит с указателем после delete?
#### 1.Память освобождается:

Оператор delete освобождает память, выделенную ранее с помощью new, и возвращает её системе. После этого программа больше не имеет права доступа к этой памяти.

#### 2.Значение указателя не изменяется:

Сам указатель продолжает хранить адрес освобождённой памяти. Однако этот адрес больше не является допустимым для использования.

#### 3.Использование указателя после delete:

Попытка разыменовать или использовать указатель после удаления памяти приводит к неопределённому поведению. Это может вызвать сбой программы, повреждение данных или другие непредсказуемые последствия.
________________________________________________________________________________________________________________________________________________________________________________________________
### Пример
```
int* ptr = new int(42);  // Динамическое выделение памяти
std::cout << *ptr << std::endl;  // Вывод: 42

delete ptr;  // Освобождение памяти

// Теперь ptr указывает на освобождённую память
std::cout << *ptr << std::endl;  // Неопределённое поведение (UB)
```
В этом примере после вызова delete ptr:

Память, выделенная для int, освобождена.

Указатель ptr продолжает хранить адрес освобождённой памяти.

Попытка разыменовать ptr (*ptr) приводит к неопределённому поведению.
________________________________________________________________________________________________________________________________________________________________________________________________
### Что делать после удаления?
Чтобы избежать случайного использования освобождённой памяти, рекомендуется обнулить указатель после вызова delete. Это делает указатель безопасным, так как попытка разыменовать нулевой указатель обычно приводит к явному сбою (например, segmentation fault), что легче обнаружить и исправить.

Пример:

```
int* ptr = new int(42);  // Динамическое выделение памяти
std::cout << *ptr << std::endl;  // Вывод: 42

delete ptr;  // Освобождение памяти
ptr = nullptr;  // Обнуление указателя

if (ptr) {
    std::cout << *ptr << std::endl;  // Этот блок не выполнится
} else {
    std::cout << "Pointer is null" << std::endl;  // Вывод: Pointer is null
}
```
### Почему неопределённое поведение опасно?
Неопределённое поведение (UB) означает, что программа может:

Работать корректно (что делает ошибку трудноуловимой).

Завершиться с ошибкой (например, segmentation fault).

Выдать случайное значение.

Повредить данные или вызвать другие непредсказуемые последствия.

Пример:

```
int* ptr = new int(42);
delete ptr;
*ptr = 100;  // Неопределённое поведение (UB)
```
В этом примере:

Программа может работать без видимых ошибок.

Или может завершиться с ошибкой.

Или может повредить другие данные в памяти.
________________________________________________________________________________________________________________________________________________________________________________________________
### Как избежать проблем?
#### 1.Обнуляйте указатели после удаления:

После вызова delete присвойте указателю значение nullptr.

Пример:

```
delete ptr;
ptr = nullptr;
```
#### 2.Используйте умные указатели:

Умные указатели (std::unique_ptr, std::shared_ptr) автоматически управляют памятью и предотвращают ошибки, связанные с ручным удалением.

Пример с std::unique_ptr:

```
#include <memory>

std::unique_ptr<int> ptr = std::make_unique<int>(42);
// Память автоматически освободится при выходе из области видимости
```
#### 3.Избегайте повторного удаления:

Убедитесь, что каждая динамически выделенная память удаляется только один раз.

#### 4.Используйте инструменты для обнаружения ошибок:

Инструменты, такие как Valgrind, AddressSanitizer или статические анализаторы, могут помочь обнаружить использование освобождённой памяти.
________________________________________________________________________
### Итог
После удаления динамически созданной переменной значение указателя становится неопределённым.

Использование указателя после delete приводит к неопределённому поведению.

Рекомендуется обнулять указатели после удаления (ptr = nullptr).

Для безопасного управления памятью используйте умные указатели (std::unique_ptr, std::shared_ptr).