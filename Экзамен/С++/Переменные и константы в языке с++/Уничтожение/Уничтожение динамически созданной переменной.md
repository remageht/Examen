В C++ динамически созданные переменные — это переменные, память для которых выделяется в куче (heap) с помощью оператора new. Такие переменные не уничтожаются автоматически при выходе из области видимости, и их необходимо явно удалять с помощью оператора delete. Если этого не сделать, произойдёт утечка памяти (memory leak).
________________________________________________________________________
### Как удалить динамически созданную переменную?
Для удаления динамически созданной переменной используется оператор delete. Этот оператор освобождает память, выделенную ранее с помощью new, и вызывает деструктор (если переменная является объектом класса).
________________________________________________________________________
### Пример удаления динамической переменной
#### 1.Удаление простого типа:

```
int* ptr = new int(42);  // Динамическое выделение памяти для int
std::cout << *ptr << std::endl;  // Использование переменной
delete ptr;  // Освобождение памяти
ptr = nullptr;  // Рекомендуется обнулить указатель
```
#### 2.Удаление объекта класса:

```
class MyClass {
public:
    MyClass() { std::cout << "Constructor" << std::endl; }
    ~MyClass() { std::cout << "Destructor" << std::endl; }
};

MyClass* obj = new MyClass();  // Динамическое создание объекта
delete obj;  // Освобождение памяти и вызов деструктора
obj = nullptr;  // Обнуление указателя
```
Вывод:
```
Copy
Constructor
Destructor
```
________________________________________________________________________
### Что происходит при удалении?
#### 1.Вызов деструктора:

Если удаляемая переменная является объектом класса, то перед освобождением памяти вызывается её деструктор. Это позволяет освободить ресурсы, которые могли быть выделены объектом (например, динамическую память, файловые дескрипторы и т. д.).

#### 2.Освобождение памяти:

Память, выделенная в куче, возвращается системе, и её можно использовать для других целей.

#### 3.Обнуление указателя (рекомендуется):

После удаления переменной рекомендуется обнулить указатель, чтобы избежать случайного использования освобождённой памяти (dangling pointer).
________________________________________________________________________
### Ошибки при удалении динамической памяти
#### 1.Утечка памяти:

Если не вызвать delete, память не будет освобождена, и это приведёт к утечке памяти.

Пример:

```
int* ptr = new int(42);  // Утечка памяти, если delete не вызван
```
#### 2.Двойное удаление:

Попытка удалить одну и ту же память дважды приводит к неопределённому поведению (Undefined Behavior, UB).

Пример:

```
int* ptr = new int(42);
delete ptr;
delete ptr;  // Ошибка: двойное удаление
```
#### 3.Использование освобождённой памяти:

Если после удаления памяти попытаться использовать указатель, это приведёт к неопределённому поведению.

Пример:

```
int* ptr = new int(42);
delete ptr;
std::cout << *ptr;  // Ошибка: использование освобождённой памяти
```
#### 4.Удаление памяти, не выделенной через new:

Попытка удалить память, которая не была выделена через new, приводит к неопределённому поведению.

Пример:

```
int x = 42;
int* ptr = &x;
delete ptr;  // Ошибка: память не была выделена через new
```
### Удаление массивов
Если динамически создан массив (с использованием new[]), то для его удаления необходимо использовать delete[]. Использование обычного delete вместо delete[] приводит к неопределённому поведению.

Пример:

```
int* arr = new int[10];  // Динамическое выделение массива
delete[] arr;  // Корректное удаление массива
arr = nullptr;  // Обнуление указателя
```
________________________________________________________________________
### Умные указатели для автоматического управления памятью
Чтобы избежать ручного управления памятью и связанных с этим ошибок, в C++ рекомендуется использовать умные указатели из стандартной библиотеки (<memory>):

1.std::unique_ptr:

Уникальный указатель, который автоматически удаляет объект при выходе из области видимости.

Пример:

```
#include <memory>

std::unique_ptr<int> ptr = std::make_unique<int>(42);
// Память автоматически освободится при выходе из области видимости
```
2.std::shared_ptr:

Указатель с подсчётом ссылок. Память освобождается, когда последний shared_ptr выходит из области видимости.

Пример:

```
#include <memory>

std::shared_ptr<int> ptr = std::make_shared<int>(42);
// Память освободится, когда все shared_ptr будут уничтожены
```
________________________________________________________________________
### Итог

Динамически созданные переменные удаляются с помощью оператора delete.

Для массивов, созданных через new[], используется delete[].

После удаления памяти рекомендуется обнулить указатель.

Использование умных указателей (std::unique_ptr, std::shared_ptr) помогает избежать утечек памяти и ошибок, связанных с ручным управлением памятью.

Неправильное использование delete (например, двойное удаление или удаление невыделенной памяти) приводит к неопределённому поведению.