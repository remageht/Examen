В C++ значение неинициализированной переменной простого типа (например, int, float, double, bool, указатели и т. д.) не определено. Это означает, что переменная может содержать "мусор" — случайное значение, которое находилось в той области памяти, где была выделена переменная. Использование такой переменной до её инициализации приводит к неопределённому поведению (Undefined Behavior, UB).
________________________________________________________________________
### Что такое "мусор"?
"Мусор" — это значение, которое осталось в памяти после предыдущих операций. Это может быть:

Остаточные данные от предыдущих программ.

Значения, оставшиеся после работы других функций или переменных.

Случайные биты, которые находились в выделенной памяти.
________________________________________________________________________
### Пример неинициализированных переменных
```
#include <iostream>

int main() {
    int x;          // Неинициализированная переменная
    double y;       // Неинициализированная переменная
    bool z;         // Неинициализированная переменная
    int* ptr;       // Неинициализированный указатель

    std::cout << "x: " << x << std::endl;  // Мусор (случайное значение)
    std::cout << "y: " << y << std::endl;  // Мусор (случайное значение)
    std::cout << "z: " << z << std::endl;  // Мусор (случайное значение)
    std::cout << "ptr: " << ptr << std::endl;  // Мусор (случайный адрес)

    return 0;
}
```
Вывод этого кода непредсказуем. Например:
```
x: 32767
y: 2.07448e-317
z: 64
ptr: 0x7ffee4d5b9a0
```
Каждый раз при запуске программы значения могут быть разными.
#### Итог
Неинициализированные переменные простых типов в C++ содержат "мусор" — случайные значения, которые находились в памяти. Использование таких переменных приводит к неопределённому поведению. Всегда инициализируйте переменные при объявлении, чтобы избежать ошибок и сделать код более безопасным и предсказуемым.
________________________________________________________________________

## Почему именно так?
Поведение неинициализированных переменных в C++ связано с тем, как работает управление памятью в этом языке. Давайте разберёмся, почему неинициализированные переменные содержат "мусор" и почему это приводит к неопределённому поведению.

### 1. Как выделяется память для переменных?
Когда вы объявляете переменную, компилятор резервирует для неё место в памяти (например, в стеке для локальных переменных или в глобальной памяти для глобальных переменных). Однако компилятор не очищает эту память автоматически. Это означает, что выделенная память может содержать данные, оставшиеся от предыдущих операций (например, от других переменных или программ).

### 2. Почему память не очищается автоматически?
Очистка памяти (например, установка нулевых значений) требует дополнительных вычислительных ресурсов. В C++ одним из ключевых принципов является "не платить за то, что не используется" (zero-overhead principle). Это означает, что язык не выполняет лишних действий, если они не требуются явно. Если программист не указал инициализацию, компилятор предполагает, что это сделано намеренно, чтобы избежать накладных расходов.

#### Итог
Неинициализированные переменные в C++ содержат "мусор", потому что память для них выделяется без очистки. Это сделано для повышения производительности, но приводит к неопределённому поведению. Чтобы избежать проблем, всегда инициализируйте переменные при объявлении и используйте инструменты компилятора для обнаружения потенциальных ошибок.